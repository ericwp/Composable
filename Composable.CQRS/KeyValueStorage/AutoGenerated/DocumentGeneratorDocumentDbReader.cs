using System;
using System.Collections.Generic;
using System.Linq;
using Composable.DDD;
using Composable.SystemExtensions.Threading;

namespace Composable.KeyValueStorage.AutoGenerated
{
    public class DocumentGeneratorDocumentDbReader : IDocumentDbReader
    {
        private readonly ISingleContextUseGuard _usageGuard;
        private readonly IDocumentDbSessionInterceptor _interceptor;
        private readonly IEnumerable<IDocumentGenerator> _documentGenerators;
        private readonly InMemoryObjectStore _idMap = new InMemoryObjectStore();
        public DocumentGeneratorDocumentDbReader(ISingleContextUseGuard usageGuard, IDocumentDbSessionInterceptor interceptor, IEnumerable<IDocumentGenerator> documentGenerators )
        {
            _usageGuard = usageGuard;
            _interceptor = interceptor;
            _documentGenerators = documentGenerators;
        }

        public void Dispose()
        {
        }

        public virtual TValue Get<TValue>(object key)
        {
            _usageGuard.AssertNoContextChangeOccurred(this);
            TValue value;
            if (TryGet(key, out value))
            {
                return value;
            }

            throw new NoSuchDocumentException(key, typeof(TValue));
        }

        public virtual bool TryGet<TDocument>(object key, out TDocument document)
        {
            _usageGuard.AssertNoContextChangeOccurred(this);

            if (!HandlesDocumentType<TDocument>())
            {
                document = default(TDocument);
                return false;
            }

            var documentType = typeof(TDocument);            

            if (documentType.IsInterface)
            {
                throw new ArgumentException("You cannot query by id for an interface type. There is no guarantee of uniqueness");
            }            

            if (_idMap.TryGet(key, out document) && documentType.IsInstanceOfType(document))
            {
                return true;
            }

            document = GetGeneratorsForDocumentType<TDocument>()
                .Select(generator => generator.TryGenerate((Guid)key))
                .Where(foundDocument => !Equals(foundDocument, default(TDocument)))
                .SingleOrDefault();
            if(!Equals(document, default(TDocument)))
            {
                _interceptor.AfterLoad(document);
                _idMap.Add(key, document);
                return true;
            }
            return false;
        }

        private bool HandlesDocumentType<TDocument>()
        {
            return GetGeneratorsForDocumentType<TDocument>().Any();
        }

        public virtual IEnumerable<TValue> Get<TValue>(IEnumerable<Guid> ids) where TValue : IHasPersistentIdentity<Guid>
        {
            _usageGuard.AssertNoContextChangeOccurred(this);
            return ids.Select(id => Get<TValue>(id)).ToList();
        }

        private IEnumerable<IDocumentGenerator<TDocument>> GetGeneratorsForDocumentType<TDocument>()
        {
            return _documentGenerators.OfType<IDocumentGenerator<TDocument>>().ToList();
        }
    }
}